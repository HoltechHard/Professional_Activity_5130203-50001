'''
    WEEK 05 - TASK 01: BASIC OPERATIONS WITH MATRICES

    [1]. Enter the elements of matrices A and B from the keyboard, taking into account the elements 
         in the range [10, 100]. Create a procedure to print the elements of arrays A, B in a tabular format.
    [2]. Create a procedure to calculate the sum of the elements in each row and store the results in a vector.
         Apply the procedure to matrices A and B and print the vector of results.
    [3]. Create a procedure to calculate the sum of the elements in each column and store the results in a vector. 
         Apply the procedure to matrices A and B and print the results.
    [4]. Develop a procedure that calculates the sum of transposed matrices, storing the result in the matrix 
         S = A^T + B^T
    [5]. Create a procedure to add a row to the matrix A at a given position. The row to be added should be stored
         in a vector of dimension n, generated by random numbers from 10 to 100.
    [6]. Create a procedure to add a column to matrix B at a given position. The column to be added should be
         stored in a vector of dimension n, generated by random numbers from 10 to 100.
    [7]. Given updated matrices A of size (n+1) x n and matrix B of size n x (n+1), calculate the matrix product
         and store the result in matrix P of size (n+1) x (n+ 1).

    Definition of variables:
        - n: dimensionality of matrix (n x n)
        - a: matrix A
        - b: matrix B
        - sum_rows_a, sum_rows_b: vector which contains the sum of elements for each row for matrices A and B
        - sum_cols_a, sum_cols_b: vector which contains the sum of elements for each colum for matrices A and B
        - at, bt: transpose matrices of A, B matrices
        - s: matrix sum
        - p: matrix product
        - new_ra: vector with random numbers to add new row to matrix A
        - new_cb: vector with random numbers to add new column to matrix B
        - posa: position to add new row in matrix A
        - posb: position to add new column in matrix B
'''

import random

def input_dimension():
    while True:
        try:
            n = int(input("\nInput the dimension of matrix: "))
            if n > 0:
                return n
            print("Dimension must be > 0.")
        except ValueError:
            print("Please enter an integer.")

def allocate_matrix(rows, cols, fill=0):
    return [[fill for _ in range(cols)] for _ in range(rows)]

def input_matrix(rows, cols):
    mat = allocate_matrix(rows, cols)
    for i in range(rows):
        print(f"Row {i+1}:")
        for j in range(cols):
            while True:
                try:
                    val = int(input(f"x[{j+1}]: "))
                except ValueError:
                    print("Enter an integer.")
                    continue
                if 10 <= val <= 100:
                    mat[i][j] = val
                    break
                else:
                    print("Value must be between 10 and 100")
        print()
    return mat

def print_matrix(mat):
    for row in mat:
        print(" ".join(str(x) for x in row))
    print()

def allocate_vector(n, fill=0):
    return [fill for _ in range(n)]

def calculate_sum_by_rows(mat):
    return [sum(row) for row in mat]

def calculate_sum_by_cols(mat):
    if not mat:
        return []
    rows = len(mat); cols = len(mat[0])
    return [sum(mat[r][c] for r in range(rows)) for c in range(cols)]

def print_vector(vec):
    print(" ".join(str(x) for x in vec))
    print()

def transpose_matrix(mat):
    if not mat:
        return []
    rows = len(mat); cols = len(mat[0])
    trx = allocate_matrix(cols, rows)
    for i in range(rows):
        for j in range(cols):
            trx[j][i] = mat[i][j]
    return trx

def sum_matrices(a, b):
    rows = len(a); cols = len(a[0])
    s = allocate_matrix(rows, cols)
    for i in range(rows):
        for j in range(cols):
            s[i][j] = a[i][j] + b[i][j]
    return s

def rand_vec_generate(n):
    return [random.randint(10, 100) for _ in range(n)]

def insert_row(mat, row_vec, pos):
    """
    pos is 1-based position where the new row will be inserted.
    Returns new matrix with one additional row.
    """
    if pos < 1:
        pos = 1
    if pos > len(mat) + 1:
        pos = len(mat) + 1
    new_mat = []
    insert_index = pos - 1
    for i in range(insert_index):
        new_mat.append(mat[i][:])
    new_mat.append(row_vec[:])
    for i in range(insert_index, len(mat)):
        new_mat.append(mat[i][:])
    return new_mat

def insert_col(mat, col_vec, pos):
    """
    pos is 1-based position where the new column will be inserted.
    Returns new matrix with one additional column.
    Assumes len(col_vec) == number of rows.
    """
    rows = len(mat)
    if rows == 0:
        # create rows with single column
        return [[col_vec[i]] for i in range(len(col_vec))]
    cols = len(mat[0])
    if pos < 1:
        pos = 1
    if pos > cols + 1:
        pos = cols + 1
    insert_index = pos - 1
    new_mat = allocate_matrix(rows, cols + 1)
    for r in range(rows):
        for c_before in range(insert_index):
            new_mat[r][c_before] = mat[r][c_before]
        new_mat[r][insert_index] = col_vec[r]
        for c_after in range(insert_index, cols):
            new_mat[r][c_after + 1] = mat[r][c_after]
    return new_mat

def product_matrices(a, b):
    """
    a: (n+1) x n
    b: n x (n+1)
    returns p: (n+1) x (n+1)
    """
    rows_a = len(a)
    cols_a = len(a[0])   # n
    rows_b = len(b)      # n
    cols_b = len(b[0])   # n+1
    # basic compatibility check
    if cols_a != rows_b:
        raise ValueError("Incompatible dimensions for multiplication.")
    p = allocate_matrix(rows_a, cols_b, fill=0)
    
    for i in range(rows_a):
        for j in range(cols_b):
            s = 0
            for k in range(cols_a):
                s += a[i][k] * b[k][j]
            p[i][j] = s
    return p

def main():
    random.seed()  # system time
    n = input_dimension()

    print("\nInput matrix A:")
    a = input_matrix(n, n)
    print("\nInput matrix B:")
    b = input_matrix(n, n)

    print("A:")
    print_matrix(a)
    print("B:")
    print_matrix(b)

    # sum of rows
    sum_rows_a = calculate_sum_by_rows(a)
    sum_rows_b = calculate_sum_by_rows(b)
    print("Sum of rows of A: ", end="")
    print_vector(sum_rows_a)
    print("Sum of rows of B: ", end="")
    print_vector(sum_rows_b)

    # sum of cols
    sum_cols_a = calculate_sum_by_cols(a)
    sum_cols_b = calculate_sum_by_cols(b)
    print("Sum of cols of A: ", end="")
    print_vector(sum_cols_a)
    print("Sum of cols of B: ", end="")
    print_vector(sum_cols_b)

    # S = A^T + B^T
    at = transpose_matrix(a)
    bt = transpose_matrix(b)
    s = sum_matrices(at, bt)
    print("A^T =")
    print_matrix(at)
    print("B^T =")
    print_matrix(bt)
    print("S = A^T + B^T:")
    print_matrix(s)

    # new row for A
    new_ra = rand_vec_generate(n)
    print("New row for A: ", end="")
    print_vector(new_ra)
    while True:
        try:
            posa = int(input("Insert the position (1-based) to insert new row into A: "))
            break
        except ValueError:
            print("Enter a valid integer position.")
    a = insert_row(a, new_ra, posa)
    print("\nA after inserting new row:")
    print_matrix(a)

    # new column for B
    new_cb = rand_vec_generate(n)
    print("New col for B: ", end="")
    print_vector(new_cb)
    while True:
        try:
            posb = int(input("Insert the position (1-based) to insert new column into B: "))
            break
        except ValueError:
            print("Enter a valid integer position.")
    b = insert_col(b, new_cb, posb)
    print("\nB after inserting new col:")
    print_matrix(b)

    # product A * B
    try:
        p = product_matrices(a, b)
        print("\nProduct of A and B:")
        print_matrix(p)
    except ValueError as e:
        print("Could not multiply matrices:", e)

if __name__ == "__main__":
    main()
